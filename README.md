## 4장 요약

객체 생성시 특정 구현체를 선언해야 한다  

```
Duck duck = new MallardDuck();
```

구현체를 동적으로 설정하고 싶으면 다음과 같이 작성해야 한다  

```
Duck duck;
if (picnic) {
    duck = new MallardDuck();
} else if (hunting) {
    duck = new DecoyDuck();
} else {
    duck = new RubberDuck();
}

```

여러 객체에서 위와 같이 작성하면 코드 관리와 갱신이 어려워짐  

<br>

인터페이스에 맞춰서 코딩하면 시스템의 변화에 대응할 수 있다  

인터페이스를 통해 만들어진 코드는 다형성을 통해 사용할 수 있지만  

특정 클래스를 많이 사용하면 다른 클래스가 추가될 때마다 코드를 고쳐야 한다  


## 객체지향 원칙

**의존성 역전 원칙(Dependency Inversion Principle)**  

추상화된 것에 의존하게 만들고, 특정 객체에 의존하지 않게 한다  


## 추상 팩토리 패턴

특정 클래스에 의존하지 않고도 서로 연관되거나 의존적인 객체들을 생성하는 메서드를 제공하는 인터페이스  

인터페이스를 구현하여 실제 인스턴스를 생성한다  

-> 어떤 인스턴스를 생성할지는 구현체마다 다르다  

추상 팩토리 패턴에서 팩토리 메서드를 사용할 수도 있다  

## 팩토리 메서드 패턴

인터페이스/추상 클래스에 객체 생성 메서드를 선언  

서브 클래스에서 메서드를 오버라이딩해서 구체적인 인스턴스 결정  

-> 객체 생성을 캡슐화할 수 있다  


실행 중에 서브 클래스에서 구체적인 인스턴스를 결정하는 것이 아님  

사용하는 서브 클래스에 따라 생산되는 객체 인스턴스가 결정된다  

## 비교

공통점  

객체 생성과 객체 사용을 분리  

객체 생성을 캡슐화하여 특정 객체에 의존하지 않도록 함 (느슨한 결합)  

<br>


차이점  

* 추상 팩토리  

    * 객체를 생성할 메서드를 제공 -> 여러 개의 생성 메서드 제공   

    * 구현을 통해 반환 타입에 맞는 특정 인스턴스를 생성한다

* 팩토리 메서드
    * 상속(객체 생성 메서드 오버라이딩)으로 객체 생성
    * 서브 클래스에 따라서 생성할 객체 인스턴스가 결정됨
    * 해당 메서드에서만 객체 생성 가능
