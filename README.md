## 3장 요약

상속을 남용하면 확장하기 어렵다  

* 행동을 상속받으면 그 행동은 컴파일 시점에 완전히 결정된다  

* 모든 서브 클래스는 동일한 행동을 상속받는다  


<br>

구성(composition)과 위임으로 행동을 상속하는 방법을 사횽할 수 있다  

* 실행 중에 객체의 행동을 설정 할 수 있음 (동적)

* 기존 코드를 수정하지 않고 기능 추가  

* 코드 변경으로 인해 의도치 않은 부작용 원천 봉쇄

-> 변경에는 닫혀있고 확장에는 열려 있는 구조

## 객체지향 원칙

**OCP(Open-Closed Principle) 원칙**  

클래스의 확장은 열려있고, 변경은 닫혀있어야 한다  

클래스를 확장하고, 원하는 행동을 추가할 수 있으나 기존 클래스를 변경하지 않는다  

OCP를 모든 부분에서 준수하는 것은 불가능, 오히려 코드 복잡도가 높아질 수 있다  


## 데코레이터(장식) 패턴


클래스의 코드를 수정하지 않고 기능을 확장해주는 패턴이다  

데코레이터는 래퍼 클래스로서 기존 클래스를 감싸서 추가 기능을 제공함  

<br>

* 기존 클래스와 서브 클래스 그룹  

* 기존 클래스를 상속받은 추상 데코레이터 클래스와 구현체 그룹

<br>

데코레이터 구현체 생성시 동일 타입의 클래스를 주입받는다  

-> 데코레이터는 래퍼 클래스이고 내부에 의존 객체를 참조하고(감싸고) 있는 형태  

<br>

최상위 타입이 동일하기 때문에 참조 및 오버라이딩 가능  

의존 객체에게 행동을 위임하고 추가 기능을 제공  

<br>

여러 개의 데코레이터를 적용 가능

실행 중에 데코레이터 적용 가능  

<br>

객체에 추가 요소를 동적으로 더할 수 있다  

데코레이터 패턴을 사용하면 서브클래스를 만들 때보다 유연하게 기능을 확장할 수 있다  

자바 I/O API가 데코레이터 패턴을 바탕으로 만들어짐  




